/*-----------------------------------------------------------------------
<copyright file="SmtpAppenderWithPathAndExceptionTypeInSubject.cs" company="Environmental Science Associates">
Copyright (c) Environmental Science Associates. All rights reserved.
<author>Environmental Science Associates</author>
</copyright>

<license>
This program is free software: you can redistribute it and/or modify
it under the terms of the GNU Affero General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Affero General Public License <http://www.gnu.org/licenses/> for more details.

Source code is available upon request via <support@sitkatech.com>.
</license>
-----------------------------------------------------------------------*/
using System;
using System.Activities.Statements;
using System.Collections.Generic;
using System.Linq;
using DocumentFormat.OpenXml.Bibliography;
using DocumentFormat.OpenXml.Drawing.Charts;
using DocumentFormat.OpenXml.Drawing;
using DocumentFormat.OpenXml.Office2013.Drawing.ChartStyle;
using System.Web.Caching;
using log4net.Appender;
using log4net.Core;

namespace LtInfo.Common
{
    /// <summary>
    /// The base SmtpAppender is capable of buffering log events based on it's configuration
    /// The subject of an email generated by this appender will be modified only if one log event is queued
    /// Otherwise, this appender behaves the same as the standard SmtpAppender
    /// Recommended configuration to take advantage of this customization is:
    ///   &lt;appender name="SmtpAppender" type="LtInfo.Common.SmtpAppenderWithPathAndExceptionTypeInSubject, LtInfo.Common"&gt;
    ///     &lt;to value="bob@company.com" /&gt;
    ///     &lt;from value="alice@company.com" /&gt;
    ///     &lt;subject value="Alert: application error" /&gt;
    ///     &lt;smtpHost value="server" /&gt;
    ///     &lt;bufferSize value="1" /&gt;
    ///     &lt;threshold value="ERROR"/&gt;
    ///     &lt;layout type="log4net.Layout.PatternLayout"&gt;
    ///       &lt;conversionPattern value="%date;%thread;%-5level;%logger;%newline%newline%message" /&gt;
    ///      &lt;/layout&gt;
    ///   &lt;/appender&gt;
    /// </summary>
    public class SmtpAppenderWithPathAndExceptionTypeInSubject : SmtpAppender
    {
        private string _baseSubject;
        private string BaseSubject
        {
            get
            {
                if (string.IsNullOrEmpty(_baseSubject))
                    _baseSubject = Subject;
                return _baseSubject;
            }
        }

        protected override void SendBuffer(LoggingEvent[] events)
        {
            // The base SmtpAppender is capable of buffering log events based on it's configuration. So the subject of an email generated by this appender can only modified if a single log event is queued
            if (events.Length == 1)
            {
                var theSingleEvent = events[0];
                var context = System.Web.HttpContext.Current;
                var exception = theSingleEvent.ExceptionObject;

                var pathAndQuery = context == null ? string.Empty : context.Request.HttpMethod + " " + context.Request.Url.PathAndQuery;
                var rootExceptionType = ExceptionToInfoForMessageSubjectIfAny(exception);
                var pathAndException = string.Join(" ", (new[] {pathAndQuery, rootExceptionType}).Where(s => !string.IsNullOrWhiteSpace(s)));
                var additionalDetails = (!string.IsNullOrWhiteSpace(pathAndException) ? string.Format(" {0}", pathAndException) : string.Empty);

                Subject = BaseSubject + additionalDetails;
            }
            base.SendBuffer(events);
        }

        /// <summary>
        /// Pulls out exception information from exception if any into something that can fit into an email message subject
        /// </summary>
        /// <param name="exception">Could be null</param>
        /// <returns>A string representing the entire exception chained together such as: SqlException--->Win32Exception</returns>
        private static string ExceptionToInfoForMessageSubjectIfAny(Exception exception)
        {
            var exceptionTypes = new List<string>();
            var currentException = exception;
            while (currentException != null)
            {
                exceptionTypes.Add(currentException.GetType().Name);
                currentException = currentException.InnerException;
            }
            var exceptionTypesRolledUp = String.Join("--->", exceptionTypes);
            return exceptionTypesRolledUp;
        }
    }


    /// <summary>
    /// Caching version of the standard log4net SmtpAppender.This appender will
    /// cache log events that are to be sent out via Smtp andsend them in block.
    ///
    /// Configuration options:
    ///
    /// <FlushInterval value="hh:mm:ss" />
    /// Indicates the periodic interval for log events flushing(e.g.sending and e-mail), specified
    /// as a time span. If the value of FlushInterval is 0:0:0 (zero), periodic interval flushing
    /// is surpressed. Default value: 0:1:0 (1 minutes).
    ///
    /// <FlushCount value="x" />
    /// Indicates the number of log events received by the appender which will trigger flushing
    /// (e.g. sending and e-mail). If the value FlushCount is 0, buffer flush triggering based
    /// the number of log events received is surpressed. Default value: 20 events.
    ///
    /// <MaxBufferSize value="x"/>
    /// Maximum number of log events, both SmtpCachingAppender events and context events to save
    /// in the cache buffer. If more than MaxBufferSize events are received before the flushing
    /// criteria is met, only the newest MaxBufferSize events are saved in the buffer.A value
    /// of 0 indicates no limit in the size of the cache. Default value: 0 (no limit)
    ///
    /// Sample SmtpCachingAppender configuration (in addition to all standard SmtpAppender options).
    /// Note the namespace and assembly name for the appender.
    ///
    /// <appender name="SmtpCachingAppender" type="log4net.Extensions.SmtpCachingAppender, Utilities">
    /// . . .
    /// <FlushInterval value="00:05:00" />
    /// <FlushCount value="20" />
    /// <MaxBufferSize value="3"/>
    /// </appender>
    ///
    /// </summary>
    public class SmtpCachingAppender : SmtpAppenderWithPathAndExceptionTypeInSubject
    {
        // Configuration options
        private int _flushCount = 20;
        private TimeSpan _flushInterval = new TimeSpan(0, 1, 0);
        private int _maxBufferSize = 0;

        // Appender state data
        private System.Threading.Timer _timer;
        private bool _timedFlush = false;
        private int _numCachedMessages = 0;
        private List<LoggingEvent> _loggingEvents = new List<LoggingEvent>();

        /// <summary>
        /// TimeSpan indicating the maximum period of time elapsed before sending
        /// any cached SMTP log events.
        /// </summary>

        public TimeSpan FlushInterval
        {
            get { return _flushInterval; }

            set { _flushInterval = value; }
        }

        /// <summary>
        /// Maximium number of SMTP events to cache before sending via SMTP.
        /// </summary>

        public int FlushCount
        {
            get { return _flushCount; }

            set { _flushCount = value; }
        }

        public int MaxBufferSiz
        {
            get { return _maxBufferSize; }

            set { _maxBufferSize = value; }
        }
        
        /// <summary>
        /// Create a timer that fires to force flushing cached log events
        /// via SMTP at a specified interval.
        /// </summary>
        public override void ActivateOptions()
        {
            if (_flushInterval > TimeSpan.Zero)

            {
                _timer = new System.Threading.Timer(
                    new
                        System.Threading.TimerCallback(OnTimer),
                    null,
                    _flushInterval,
                    _flushInterval);
            }

            base.ActivateOptions();
        }


        void OnTimer(Object stateInfo)
        {
            _timedFlush = true;
            Flush(true);
        }

        protected override void SendBuffer(LoggingEvent[] events)
        {
            if (_maxBufferSize != 0)

            {
                int numRemoved = _loggingEvents.Count - _maxBufferSize;

                if ((numRemoved > 0) && (numRemoved <= _loggingEvents.Count))

                {
                    _loggingEvents.RemoveRange(0, numRemoved);
                }
            }


            _numCachedMessages++;

            if (((_flushCount != 0) && (_numCachedMessages >= _flushCount)) || _timedFlush)

            {
                if (_loggingEvents.Count > 0)

                {
                    LoggingEvent[] bufferedEvents = _loggingEvents.ToArray();


                    base.SendBuffer(bufferedEvents);


                    _loggingEvents.Clear();
                }

                // Reset cache buffer conditions.

                _numCachedMessages = 0;

                _timedFlush = false;
            }
        }
    }
}
